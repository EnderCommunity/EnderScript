#header <nothing-to-see-here>
//^ The header is used to give the compiler nessessary information before it
//starts compiling the code. Flags start with the operators "--". If you do not
//wish to pass any information to the compiler, you can just remove it.

//The available flags are:
//"no-comments": can be used to tell the compiler to not look for comments in this
//file
//"no-preprocessor-methods": can be used to tell the compiler that this file does
//not contain any preprocessor methods
//"skip-processor": can be used to tell the compiler to not compile the code after
//the header, and jump to the C compiler compiling stage.

/*

Murmur | (C) EnderCommunity
------------------------------------------------------------------------------------
This is a pitch file for Murmur that will include the syntax and structure
of Murmur, and all the functions that it can use.

(!) This is nowhere near being final, this is all just a pitch.

*/

// (!) All the functions used outside of groups are seen by the compiler as
//preprocessor functions! So any normal code outside of groups that is not a
//preprocessor-related feature will cause the compiler to exit with an error.

//using system.io; //Tell the compiler that the program is going to use the
                 //input/output library in the folder "system"
using test;
using foldertest.test2;

import "final-pitch-lib.lib.mur"; //Import another Murmur file!

define ZERO 0; //You can use the `define` function to define a variable that
               //will be replaced by the provided value before the execution
               //of this code

setsize int 2; //Set a custom size of memory (in bytes) to allocate for any type
setsize double 10; //You can do the same with all the built-in types

//import "path/to/my/file2.mur"; //You need to pay attention to the importing order
//of your files! For example, "file.mur" will not be able to use the custom set
//amount of memory for the 'int' variable, whereas "file2.mur" will be able to
//use it with no problem whatsoever.

// (!) Modules may not be necessary anymore with this new arrangement

public group FinalPitch { //Groups can help you keep a whole block of code within one
              //structure to better organise your code

    //Groups can only contain classes, any normal code here will cause the
    //program to crash.

    public class Program { //Classes can be used to completely separate functions from one
                    //another, in case you wanted to prevent other classes from
                    //accessing some variables or functions

        public variable::int globA = 0;
        public variable::double globB = 0.0;
        public variable::float globC = 0.0;
        public variable::char globD = 'D';
        public variable::string globE = "Global E";
        public variable::bool globF = true;
        public variable::file globG = new FileStream("path/to/my/file.txt");
        public variable::hex globH = 0xFF;
        public variable::string[] globI = new Array::string[](6);
        private variable::hex[,] globJ = new Array::hex[,](8, 2);

        public function::int Main(envi::string[], length::int){ //This is the main
                                                       //function in the program!
                                                       //All Murmur programs
                                                       //should include a main
                                                       //function.

            //This is a public function! (It can be accessed from anywhere
            //outside this class)

            Func(); //You can access any function inside this class

            variable::^int a = 0; //This variable will allocate the custom set amount of
                        //memory specified at the start of this program!

            variable::int b = 1; //This variable will allocate the default amount of
                       //memory set by the compiler

            variable::^int c = Test(a, 1); //You can pass all types of variables to other functions

            a = 1, c = 5; //Change the value of 'c' to '5'm and the value of 'a' to '1'

            PlusOne(b:ref); //the value of 'b' is '2' now!

            variable::bool myTest = false;

            if(myTest == true){ //This condition is impossible

                //Anything here will never manage to run

            }else{

                //Hmm

            }

            if(myTest != true){ //This condition is possible

                //...

            }

            if(1 >= 5 || 1 > 5 || (1 > 1 && 1 < 1)){ //These conditions are impossible

                //Anything here will never manage to run

            }

            if(1 <= 5 || 1 < 5){ //These conditions are possible

                //...

            }

            return 0; //This is the final program output code

        }

        private function::void Func(){
                        //^ This is the return type of the function!

            //This is a private function! (It can be accessed only by
            //other functions inside this class)

            //Your code goes here!

        }

        public function::^int Test(a::^int, b::int){

            a = (^int) b; //Do not support this!
            // First, add a library that can take care of this stuff.

            return a;

        }

        public function::void PlusOne(a::int:ref){ //with the keyword "ref", you can make changes to the originally passed variable within this function
                                    //^ "reference"
                                    //int og = 0;
                                    //PlusOne(og:ref);

            a++; //the value of 'og' will change to '1'!

        }

        public function::void myTests(){

            variable::bool myTest = false;
            variable::int a = 0, b = 0;
            variable::double c = 4, d = 3;

            myTest!!; //This is the same as myTest = !myTest;
            myTest = !myTest;
            a++; //This is the same as a += 1;
            a += 1;
            a = a + 1;
            b--; //This is the same as b -= 1;
            b -= 1;
            b = b - 1;

            c %= d; //This is the same as  c = c % d;
            c % d; //The result is 1!
            c /= 0.5; //This is the same as  c = c / 0.5;
            c / d; //The result is 0.66666666!
            c *= d; //This is the same as  c = c * d;
            c = c * d;

        }

        function::string myStringTest(a::string){

            variable::string b = "Hi!";
            delete b; // You can delete variables using
                      // the keyword "delete".
                      // (But you can only do that on
                      // the level of your current
                      // zone!)
            variable::int b = 1;

            // Also, you can't delete any variables
            // that are passed as arguments to the
            // function, class-level variables, or
            // constants.

        }

        function::hex[,] ReturnHexArray(){

            return this.globJ;

        }

    }

    public class AnotherClass {

        public variable::int a = 0;
        private variable::int b = 0;

        public function::AnotherClass Construct(a::int, b::int){ //You can use constructors in your classes!

            this.a = a;
            this.b = b;

        }

    }

    class Smth { //Any object with no state indicator will be set to 'public' by default

        function::void myTest(a::int){

            //

        }

    }

}